import { asyncHandler } from '../utils/asyncHandler.js';
import { ApiError } from '../utils/apiError.js';
import { ApiResponse } from '../utils/apiResponse.js';
import { User } from '../models/user.model.js';


// options for cookies
const cookieOptions = {
  httpOnly: true,
  secure: true
};

// Generate the access and refresh tokens for the users
const generateAccessAndRefreshTokens = async (userId) => {
  try {
    const user = await User.findById(userId);

    const accessToken = user.generateAccessToken();
    const refreshToken = user.generateRefreshToken();

    user.refreshToken = refreshToken;

    await user.save({ validateBeforeSave: false });

    return { accessToken, refreshToken };
  } catch (error) {
    return res.status(500).json({ message: 'Error while generating access and refresh tokens' });
  }
};


// Integrate OTP based login

// Register the User
const register = asyncHandler(async (req, res) => {
  const { fullName, email, password } = req.body;
  const { firstName, lastName } = fullName;

  if(
    [firstName, lastName, email, password].some(field => field.trim() === "")
  ) {
    throw new ApiError(404, 'All fields are required');
  }

  if(!email.includes("@")) {
    throw new ApiError(400, "Please enter a valid email address");
  }

  const existingUser = await User.findOne({ email });

  if(existingUser) {
    throw new ApiError(404, 'User already exists');
  }

  // Register the user

  // This is the avatar generated by DiceBear having initials of the uses's first name and last name
  const avatar = `https://api.dicebear.com/9.x/initials/svg?seed=${firstName.charAt(0)}${lastName.charAt(0)}&radius=50`;

  const user = await User.create({
    fullName,
    email,
    password,
    avatar
  });

  if(!user) {
    throw new ApiError(500, 'Error while creating the user');
  }

  const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(user._id);

  return res
  .status(200)
  .cookie('accessToken', accessToken, cookieOptions)
  .cookie('refreshToken', refreshToken, cookieOptions)
  .json(
    new ApiResponse(
      200,
      {
        user,
        accessToken,
        refreshToken
      }
    ),
    'User registered successfully'
  )
});

const login = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  if(
    [email, password].some(field => field.trim() === "")
  ) {
    throw new ApiError(404, 'All fields are required');
  }

  if(!email.includes("@")) {
    throw new ApiError(400, "Please enter a valid email address");
  }

  const user = await User.findOne({ email });

  if(!user) {
    throw new ApiError(404, 'User not found');
  }

  if(!await user.comparePassword(password)) {
    throw new ApiError(400, 'Invalid Password');
  }

  const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(user._id);

  
  return res
  .status(200)
  .cookie('accessToken', accessToken, cookieOptions)
  .cookie('refreshToken', refreshToken, cookieOptions)
  .json(
    new ApiResponse(
      200,
      {
        user,
        accessToken,
        refreshToken
      },
      'Logged in successfully'
    )
  )
});

const logout = asyncHandler(async (req, res) => {
  await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: {
        refreshToken: undefined
      }
    },
    {
      new: true
    }
  )

  return res
  .status(201)
  .clearCookie("accessToken", cookieOptions)
  .clearCookie("refreshToken", cookieOptions)
  .json(
      new ApiResponse(200, {}, "User loged out")
  )
});

const getCurrentUser = asyncHandler(async (req, res) => {
  return res
  .status(200)
  .json(
    new ApiResponse(200, req.user, "Current user fetched successfully")
  );
});

const refreshAccessToken = asyncHandler(async(req, res) => {  // renew acces token -> (renew session)
  const userRefreshToken = req.cookies.refreshToken || req.body.refreshToken;

  if(!userRefreshToken) {
    throw new ApiError(401, "Unauthorized request");
  }
  
  try {
    const decodedToken = jwt.verify(userRefreshToken, process.env.REFRESH_TOKEN_SECRET);

    const user = await User.findById(decodedToken?._id);

    if(!user) {
      throw new ApiResponse(401, "Invalid refresh token");
    }

    if(user.refreshToken !== userRefreshToken) {
      throw new ApiError(401, "Refresh Token is expired or used");
    }

    const newTokens = await generateAccessAndRefreshToken();

    return res
    .status(200)
    .cookie("accessToken", newTokens.accessToken, cookieOptions)
    .cookie("refreshToken", newTokens.refreshToken, cookieOptions)
    .json(
      new ApiResponse(
        200,
        {
          accessToken: newTokens.accessToken,
          refreshToken: newTokens.refreshToken
        },
        "Access token refreshed successfully"
      )
    )
  } catch (error) {
    throw new ApiError(401, error?.message || "Invalid refresh token");
  }
});

const changePassword = asyncHandler(async (req, res) => {
  const { oldPassword, confirmOldPassword, newPassword } = req.body;

  if(oldPassword !== confirmOldPassword) {
    throw new ApiError(401, "Password and confirm password does not match");
  }

  const user = await User.findById(req.user?._id);

  if(!user.isPasswordCorrect(oldPassword)) {
    throw new ApiError(401, "Invalid old password");
  }

  // set new password
  user.password = newPassword;
  await user.save({ validateBeforeSave: false });

  return res
  .status(200)
  .json(
    new ApiResponse(200, {}, "Password changed successfully")
  );
});

const updateAccountDetails = asyncHandler( async (req, res) => {
  const {fullName, email} = req.body;

  if(!fullName && !email) {
    throw new ApiError(400, "Please provide the required details that you want to change");
  }
  
  const updates = {};
  
  if(fullName) updates.fullName = fullName;
  if(email) updates.email = email;
  
  const user = await User.findByIdAndUpdate(
    req.user._id,
    updates,
    {
      new: true
    }
  ).select("-password");

  return res
  .status(200)
  .json(
    new ApiResponse(200, user, "Account details updated")
  )
});

export {
  register,
  login,
  logout,
  getCurrentUser,
  refreshAccessToken,
  changePassword,
  updateAccountDetails
}